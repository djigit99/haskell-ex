-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SmallCheck support for the Tasty test framework.
--   
--   SmallCheck support for the Tasty test framework.
@package tasty-smallcheck
@version 0.8.1


-- | This module allows to use SmallCheck properties in tasty.
module Test.Tasty.SmallCheck

-- | Create a <tt>Test</tt> for a SmallCheck <a>Testable</a> property
testProperty :: Testable IO a => TestName -> a -> TestTree

-- | The "depth" parameter for SmallCheck
newtype SmallCheckDepth
SmallCheckDepth :: Int -> SmallCheckDepth

-- | Quantify the function's argument over its <a>series</a>, but adjust
--   the depth. This doesn't affect any subsequent variables.
changeDepth1 :: (Show a, Serial m a, Testable m b) => (Depth -> Depth) -> (a -> b) -> Property m

-- | Run property with a modified depth. Affects all quantified variables
--   in the property.
changeDepth :: Testable m a => (Depth -> Depth) -> a -> Property m

-- | The <a>==&gt;</a> operator can be used to express a restricting
--   condition under which a property should hold. It corresponds to
--   implication in the classical logic.
--   
--   Note that <a>==&gt;</a> resets the quantification context for its
--   operands to the default (universal).
(==>) :: (Testable m c, Testable m a) => c -> a -> Property m
infixr 0 ==>

-- | Set the uniqueness quantification context.
--   
--   Bear in mind that ∃! (x, y): p x y is not the same as ∃! x: ∃! y: p x
--   y.
--   
--   For example, ∃! x: ∃! y: |x| = |y| is true (it holds only when x=0),
--   but ∃! (x,y): |x| = |y| is false (there are many such pairs).
--   
--   As is customary in mathematics, <tt><a>existsUnique</a> $ \x y -&gt; p
--   x y</tt> is equivalent to <tt><a>existsUnique</a> $ \(x,y) -&gt; p x
--   y</tt> and not to <tt><a>existsUnique</a> $ \x -&gt;
--   <a>existsUnique</a> $ \y -&gt; p x y</tt> (the latter, of course, may
--   be explicitly written when desired).
--   
--   That is, all the variables affected by the same uniqueness context are
--   quantified simultaneously as a tuple.
existsUnique :: Testable m a => a -> Property m

-- | Set the existential quantification context
exists :: Testable m a => a -> Property m

-- | Set the universal quantification context
forAll :: Testable m a => a -> Property m

-- | Execute a monadic test
monadic :: Testable m a => m a -> Property m

-- | <tt><a>over</a> s $ \x -&gt; p x</tt> makes <tt>x</tt> range over the
--   <a>Series</a> <tt>s</tt> (by default, all variables range over the
--   <a>series</a> for their types).
--   
--   Note that, unlike the quantification operators, this affects only the
--   variable following the operator and not subsequent variables.
--   
--   <a>over</a> does not affect the quantification context.
over :: (Show a, Testable m b) => Series m a -> (a -> b) -> Property m

-- | The type of properties over the monad <tt>m</tt>
data Property (m :: Type -> Type)

-- | Class of tests that can be run in a monad. For pure tests, it is
--   recommended to keep their types polymorphic in <tt>m</tt> rather than
--   specialising it to <tt>Identity</tt>.
class Monad m => Testable (m :: Type -> Type) a
test :: Testable m a => a -> Property m

-- | Maximum depth of generated test values.
--   
--   For data values, it is the depth of nested constructor applications.
--   
--   For functional values, it is both the depth of nested case analysis
--   and the depth of results.
type Depth = Int

-- | An explanation for the test outcome
type Reason = String
instance GHC.Real.Integral Test.Tasty.SmallCheck.SmallCheckDepth
instance GHC.Enum.Enum Test.Tasty.SmallCheck.SmallCheckDepth
instance GHC.Real.Real Test.Tasty.SmallCheck.SmallCheckDepth
instance GHC.Classes.Eq Test.Tasty.SmallCheck.SmallCheckDepth
instance GHC.Classes.Ord Test.Tasty.SmallCheck.SmallCheckDepth
instance GHC.Num.Num Test.Tasty.SmallCheck.SmallCheckDepth
instance Test.Tasty.Options.IsOption Test.Tasty.SmallCheck.SmallCheckDepth
instance Test.Tasty.Core.IsTest (Test.SmallCheck.Property.Property GHC.Types.IO)
